## Perl Nitro Booster

これだけ押さえておけば、あとは何とかなるんじゃないかな？

---

# 1. お約束

---

## お約束

* 改行コードは"\n"(LF)一択。(CR LF)とかダメ。
* 各処理の最後は";"(セミコロン)
* とりあえず書こう`use strict;` `use warnings;`
* 日本語使うなら`use utf8;`
* 日本語を出力したいときは`binmode STDOUT, 'utf8';`

---

# 2. シンプルなの書いてみよう

---

## シンプルなの書いてみよう

    use strict;
    use warnings;
    print "Hello, ". "world!\n";

これを`hello.pl`として保存。

---

## 実行してみよう

    perl hello.pl

---

## 解説

* `print`という命令を使うと、ターミナルに任意の文字列を表示できる
* `"`を使うと、文字列を表現できる。
* `\n` というのは改行コード。「メタ文字」の項で解説します。
* 各処理の末尾には`;`がありますね！
* `.`は文字列どうしを繋ぎ合わせる演算子です。

---

# 3. 変数

こういうの。

    my $item = 'perl';
    print "Hello, $item world!\n";

---

## 解説

`$nantoka` っていうのが変数。
Perlの変数には文字列も数値も入れられる。何でも来い。

このように、**単一の値を格納できる変数**を`スカラ変数`と呼びます。

変数宣言するときには、`my` をつかって宣言する。

なお、`$`の部分を`シジル`と呼び、`$`は**スカラ変数であることを示すシジル**です。

---

# 4. メタ文字

乱暴にいうと、`\` と何かで表現できるやつ。以下、頻出するやつ。

* `\n` 改行
* `\t` タブ
* `\r` リターンフィード。windowsのメモ帳で書くとこれがついてきて邪魔。
* `\s` スペース文字。「正規表現」という機能で使うことが多いです。
* `\d` 数値文字。0〜9（半角全角！）のどれか。これも「正規表現」でよく使います。

---

## メタ文字とクォート

3に出てきたprintするやつで、クォートを他のに取り替えたら結構大ごとに。

    print "Hello, $item world!\n";

↓

    print 'Hello, $item world!\n';

---

## 解説

`""`で囲った文字列に変数やメタ文字を入れた場合は、変数やメタ文字は展開されるけど、`''`で囲った文字列はそのようにはならない。

---

# 5. 数値演算

電卓の代わり。

    use strict;
    use warnings;
    use utf8;
    
    binmode STDOUT, 'utf8';
    
    my $width = 14;
    my $height = 37;
    my $triangle = ( $width * $height ) / 2;
    
    printf "幅%dcm 高さ%dcmの三角形の面積は%0.02fcm2です\n", $width, $height, $triangle;

---

## 解説

* 三角形の面積 = `(幅 x 高さ)÷2` を、`$triangle`を求める式で表現。
* `printf`命令は、最初の引数でフォーマットを指定し、`%d`とか`%s`とか`%0.03f`みたいな場所に、続きの引数を順番に当て込んで、ターミナルに出力。
* 日本語を使っているので、`use utf8;`しています。
* 日本語を出力するので、`binmode STDOUT, 'utf8';`します。

---

## 数値演算子

よく使うやつだけ書いてみた。

* `*` 掛け算
* `-` 引き算
* `+` 足し算
* `/` 割り算
* `**` べき乗
* `++` インクリメント
* `--` デクリメント

詳細は[このあたり](http://perldoc.jp/docs/perl/perlop.pod)を読むと良いです。

---

# 6. 条件分岐と比較演算

もし＊＊が○○だったら、□□する、みたいなやつ。

    my $item = 'perl';
    if ( $item eq 'perl' ) {
        print "Hello, amazing perl world!\n";
    }
    elsif ( $item eq 'java' ) {
        print "Hello, bourjois java world!\n";
    }
    else {
        print "Hello, $item world!\n";
    }

---

## 数値比較用演算子

よく使うやつだけ書いてみた

* `==` 両辺が数値的に等しい場合、`true`
* `!=` 両辺が数値的に等しくない場合、`true`

* `>`  左辺が右辺より数値的に大きい場合、`true`
* `>=` 左辺が数値的に右辺以上である場合、`true`
* `<`  左辺が右辺より数値的に小さい場合、`true`
* `<=` 左辺が数値的に右辺以下である場合、`true`

---

## 文字列比較用演算子

よく使うやつだけ書いてみた

* `eq` 両辺が同じ文字列である場合、`true`
* `ne` 両辺が違う文字列である場合、`true`

---

## その他の演算子

よく使うやつだけ書いてみた

* `&&` AND演算。
* `||` OR演算。
* `!`  NOT演算。

---

# 7. 配列とループ

    use utf8;
    binmode STDOUT, 'utf8';
    
    my @favlist = ('餃子', 'インドカレー', '生春巻き');
    
    for my $fav ( @favlist ) {
        print "僕は$favが好きです！\n";
    }

配列は`@`で始まる変数の一種で、複数の変数がまとめられたものであり、順番が保証されます。

なお、`@`は**配列であることをしめすシジル**です。

---

## 要素を一個だけ取り出したいとき

    use utf8;
    binmode STDOUT, 'utf8';
    
    my @favlist = ('餃子', 'インドカレー', '生春巻き');
    print $favlist[1]; # 'インドカレー' が出力される
    
`$配列名[要素番号]` で取り出せます。要素番号は0が最初！

---

## forループ

    for my $item ( @items ) {
        # ここに処理コードを書く
    }

配列の中身が一つ一つ、`$item`に代入され、ループ内で処理するのに使えるようになる。
配列の中身全体に何か処理をかける時に使ったりする。

---

## whileループ

    while ( $condition ) {
        # ここに処理コードを書く
    }

`$condition`には、何らかの判定結果を入れる。
すると、`$condition`が`0`か`undef`にならない限りは``無限``にループする。

---

# 8. 正規表現

* `ほげふが`って文字列に`ふが`が入ってるかどうか調べたい
* `ほげふが`から`ふが`を抜き出したい

みたいなときに使えます。

---

## 文字列検索/置換する場合

    use utf8;
    binmode STDOUT, 'utf8';
    
    my $str = 'ほげふが';
    if ( $str =~ /ふが/ ) {
        print "「ふが」ありました！\n"
        $str =~ s/ふが/ぴよ/;
    }
    print $str. "\n";

---

## 文字列を抜き出す場合

    my $str = 'hello, world';
    my ($word) = $str =~ /(.+), world/;
    print $word. "\n";

---

## かなりよく使うマッチング表現

* `\A` 文字列の始まりを表します。
* `\z` 文字列の終わりを表します。
* `+` 直前の文字の1回以上の繰り返しを表します。
* `*` 直前の文字の0回以上の繰り返しを表します。
* `(.+)` １文字でもマッチすれば、それを抜き出す。
* `[0-9]` 半角数字１文字にマッチ

正規表現は奥が深いので、[こちら](http://perldoc.jp/docs/perl/5.14.1/perlre.pod)を見ておくと良いでしょう。

---

## 正規表現のよくある罠

正規表現には`\d`という物があります。これは通常`0から9までの数値文字１文字`を表現する`文字クラス`です。

しかし、`\d`は`use utf8`されている状況下では、**半角数字だけではなく全角数字にもマッチする**ので、注意が必要です。

もしどうしても半角数字だけにマッチさせたければ、`[0-9]`を利用しましょう。

    use strict;
    use warnings;
    my $num = '３００'; ### 注意! 全角数字!
    
    ### コレはマッチしない
    if ( $num =~ /\A\d*\z/ ) {
        print "$num is number!\n"; 
    }


    use strict;
    use warnings;
    use utf8; ### コイツを使ってると、\dは全角数字にもマッチするよ！
    my $num = '３００'; ### 注意! 全角数字!
    
    ### コレはマッチする
    if ( $num =~ /\A\d*\z/ ) {
        print "$num is number!\n"; 
    }

---

# 9. ハッシュ（連想配列）

Key-value型のデータ構造。%なんとか みたいな書き方をします。
ハッシュの中の単体要素を取り出すときは `$ハッシュ名{要素名}` のように指定します。

    my %human = (
        name => 'ytnobody',
        age => 34,
        sex => male,
    );
    print "$human{name} is $human{sex}, and $human{age} years old.\n";

---

# 10. ファイルとディレクトリ

ファイルを開くときには `open` を使う。なお、モードを指定する必要が有ります。

    my $mode = '<';
    my $file = '/path/to/file.txt';
    open my $fh, $mode, $file; 

`$fh`のことを`ファイルハンドル`と呼ぶ。

--- 

## 実際の利用例

ファイルハンドルを`<`と`>`で囲ってやると、一行ずつファイルの中身を配列として持ってきてくれる。

    open my $fh, '<', '/path/to/somefile';
    for my $line (<$fh>) {
        print $line;
    }
    close $fh;

---

## ファイルオープン時のモード

* `<` : 読み込み専用
* `>` : 書き込み専用（上書きモード）
* `>>` : 書き込み専用（追記モード）

---

## ターミナルからの入力を受け取りたい

`STDIN`というファイルハンドルが最初から存在するので、それを使う

    ## Ctrl+D が押下されるまで、入力された文字列をオウム返しする。
    while (my $input = <STDIN>) {
        print $input;
    }
    
`STDIN`は`標準入力`と呼ばれる。

---

## ディレクトリの中身調べたりする

`glob` を使うと、unixの`ls`コマンドのような指定方法でファイル/ディレクトリ一覧を得ることができます。

    my @logs = glob '/path/to/some/*.log';

---

# 11. サブルーチン

`サブルーチン`とは、一連の処理をまとめたプログラムです。またの名を`関数`。`sub`命令で定義できます。

    sub make_ramen {
        print "フタ開ける\n";
        
        print "湯〜注ぐ\n";
        
        ### ここで３分間まつ
        sleep 60 * 3;           
        
        print "出来上がり\n";
    }

---

## サブルーチンを実行する

サブルーチン名の後ろに丸括弧をつけてやると、サブルーチンの中身を実行します。

    make_ramen();
    
これを`サブルーチンのコール`とか`関数呼び出し`などと呼びます。

---

## サブルーチンに引数を与えて挙動を変える

例えばこんなサブルーチンがあるとします。

    sub eat {
        my ($dish, $tableware) = @_;
        print "I eat a $dish using $tableware.\n";
    }

実際にコールするときには、以下のようにします。

    eat('sushi', 'chopsticks');
    # とか
    eat('steak', 'knife and fork');

この時、`'sushi'`や`'shopsticks'`のことを`引数`と呼び、サブルーチンのコール時に引数を指定することを`引数を渡す`と表現します。

eatサブルーチンを定義する時に利用された`@_`は、**引数が格納された特殊な配列**です。**とにかく`@_`は覚えましょう。**`@_`です。

# 12. リファレンス

`リファレンス`とは、主に`変数`,`配列`,`ハッシュ`,`ファイルハンドル`,`サブルーチン`についての参照を表現する変数です。

    ## ハッシュを定義する。
    my %human = (name => 'ytnobody', age => 34);
    
    ## ハッシュリファレンスを定義する。
    my $ref = \%human;
    
    ## ハッシュリファレンスの年齢を書き換える。
    $ref->{age} = 35;
    
    ## 元のハッシュに格納されている名前と年齢を表示する。
    printf "%s is %s years old.\n", $human{name}, $human{age};

上記のとき、結果は `ytnobody is 35 years old.` と表示されます。

**ハッシュリファレンスの内容を書き換える**箇所で、**実体であるハッシュの内容が書き換えられる**わけです。

尚、リファレンスの概念は、Perlのオブジェクト指向を習得する上で必須の知識ですので、しっかり体得しましょう。

---

## リファレンスの定義方法とデリファレンス

前述の様に、実体となり得る変数や配列などの前に `\`をつけることで、リファレンスを定義することができます。

一方で、実体を定義せずに直接リファレンスを定義することも可能です。よく使うのは`配列リファレンス`と`ハッシュリファレンス`の２種類です。

なお、各リファレンスから実体をたぐり寄せる時には`デリファレンス`と呼ばれる操作を行います。

デリファレンスは、デリファレンス先の型式に合わせて、リファレンス変数の前に対応するシジルをくっつけるだけです。

    ## 配列リファレンス
    my $array_ref = [1, 1, 2, 3, 5, 8, 13, 21]; 
    
    ## 6th item is 13. と表示。
    printf "6th item is %s.\n", $array_ref->[6];
    
    ## 配列にデリファレンスする
    my @array = @$array_ref;
    
    
    ## ハッシュリファレンス
    my $hash_ref = {name => 'ytnobody', age => 34};
    
    ## My name is ytnobody. と表示。
    printf "My name is %s.\n", $hash_ref->{name};
    
    ## ハッシュにデリファレンスする
    my %hash = %$hash_ref;
