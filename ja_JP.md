## Perl Nitro Booster

これだけ押さえておけば、あとは何とかなるんじゃないかな？

---

# 1. お約束

---

## お約束

* 改行コードは"\n"(LF)一択。(CR LF)とかダメ。
* 各処理の最後は";"(セミコロン)
* とりあえず書こう`use strict;` `use warnings;`
* 日本語使うなら`use utf8;`
* 日本語を出力したいときは`binmode STDOUT, 'utf8';`

---

# 2. シンプルなの書いてみよう

---

## シンプルなの書いてみよう

    use strict;
    use warnings;
    print "Hello, ". "world!\n";

これを`hello.pl`として保存。

---

## 実行してみよう

    perl hello.pl

---

## 解説

* `print`という命令を使うと、ターミナルに任意の文字列を表示できる
* `"`を使うと、文字列を表現できる。
* `\n` というのは改行コード。「メタ文字」の項で解説します。
* 各処理の末尾には`;`がありますね！
* `.`は文字列どうしを繋ぎ合わせる演算子です。

---

# 3. 変数

こういうの。

    my $item = 'perl';
    print "Hello, $item world!\n";

---

## 解説

`$nantoka` っていうのが変数。
Perlの変数には文字列も数値も入れられる。何でも来い。

変数宣言するときには、`my` をつかって宣言する。

---

# 4. メタ文字

乱暴にいうと、`\` と何かで表現できるやつ。以下、頻出するやつ。

* `\n` 改行
* `\t` タブ
* `\r` リターンフィード。windowsのメモ帳で書くとこれがついてきて邪魔。
* `\s` スペース文字。「正規表現」という機能で使うことが多いです。
* `\d` 数値文字。0〜9（半角全角！）のどれか。これも「正規表現」でよく使います。

---

## メタ文字とクォート

3に出てきたprintするやつで、クォートを他のに取り替えたら結構大ごとに。

    print "Hello, $item world!\n";

↓

    print 'Hello, $item world!\n';

---

## 解説

`""`で囲った文字列に変数やメタ文字を入れた場合は、変数やメタ文字は展開されるけど、`''`で囲った文字列はそのようにはならない。

---

# 5. 数値演算

電卓の代わり。

    use strict;
    use warnings;
    use utf8;
    
    binmode STDOUT, 'utf8';
    
    my $width = 14;
    my $height = 37;
    my $triangle = ( $width * $height ) / 2;
    
    printf "幅%dcm 高さ%dcmの三角形の面積は%0.02fcm2です\n", $width, $height, $triangle;

---

## 解説

* 三角形の面積 = `(幅 x 高さ)÷2` を、`$triangle`を求める式で表現。
* `printf`命令は、最初の引数でフォーマットを指定し、`%d`とか`%s`とか`%0.03f`みたいな場所に、続きの引数を順番に当て込んで、ターミナルに出力。
* 日本語を使っているので、`use utf8;`しています。
* 日本語を出力するので、`binmode STDOUT, 'utf8';`します。

---

## 数値演算子

よく使うやつだけ書いてみた。

* `*` 掛け算
* `-` 引き算
* `+` 足し算
* `/` 割り算
* `**` べき乗
* `++` インクリメント
* `--` デクリメント

詳細は[このあたり](http://perldoc.jp/docs/perl/perlop.pod)を読むと良いです。

---

# 6. 条件分岐と比較演算

もし＊＊が○○だったら、□□する、みたいなやつ。

    my $item = 'perl';
    if ( $item eq 'perl' ) {
        print "Hello, amazing perl world!\n";
    }
    elsif ( $item eq 'java' ) {
        print "Hello, bourjois java world!\n";
    }
    else {
        print "Hello, $item world!\n";
    }

---

## 数値比較用演算子

よく使うやつだけ書いてみた

* `==` 両辺が数値的に等しい場合、`true`
* `!=` 両辺が数値的に等しくない場合、`true`

* `>`  左辺が右辺より数値的に大きい場合、`true`
* `>=` 左辺が数値的に右辺以上である場合、`true`
* `<`  左辺が右辺より数値的に小さい場合、`true`
* `<=` 左辺が数値的に右辺以下である場合、`true`

---

## 文字列比較用演算子

よく使うやつだけ書いてみた

* `eq` 両辺が同じ文字列である場合、`true`
* `ne` 両辺が違う文字列である場合、`true`

---

## その他の演算子

よく使うやつだけ書いてみた

* `&&` AND演算。
* `||` OR演算。
* `!`  NOT演算。

---

# 7. 配列とループ

    use utf8;
    binmode STDOUT, 'utf8';
    
    my @favlist = ('餃子', 'インドカレー', '生春巻き');
    
    for my $fav ( @favlist ) {
        print "僕は$favが好きです！\n";
    }

配列は`@`で始まる変数の一種で、複数の変数がまとめられたものであり、順番が保証されます。

---

## 要素を一個だけ取り出したいとき

    use utf8;
    binmode STDOUT, 'utf8';
    
    my @favlist = ('餃子', 'インドカレー', '生春巻き');
    print $favlist[1]; # 'インドカレー' が出力される
    
`$配列名[要素番号]` で取り出せます。要素番号は0が最初！

---

## forループ

    for my $item ( @items ) {
        # ここに処理コードを書く
    }

配列の中身が一つ一つ、`$item`に代入され、ループ内で処理するのに使えるようになる。
配列の中身全体に何か処理をかける時に使ったりする。

---

## whileループ

    while ( $condition ) {
        # ここに処理コードを書く
    }

`$condition`には、何らかの判定結果を入れる。
すると、`$condition`が`0`か`undef`にならない限りは``無限``にループする。

---

# 8. 正規表現

* `ほげふが`って文字列に`ふが`が入ってるかどうか調べたい
* `ほげふが`から`ふが`を抜き出したい

みたいなときに使えます。

---

## 文字列検索/置換する場合

    use utf8;
    binmode STDOUT, 'utf8';
    
    my $str = 'ほげふが';
    if ( $str =~ /ふが/ ) {
        print "「ふが」ありました！\n"
        $str =~ s/ふが/ぴよ/;
    }
    print $str. "\n";

---

## 文字列を抜き出す場合

    my $str = 'hello, world';
    my ($word) = $str =~ /(.+), world/;
    print $word. "\n";

---

## かなりよく使うマッチング表現

* `(.+)` １文字でもマッチすれば、それを抜き出す。
* `[0-9]` 半角数字１文字にマッチ

正規表現は奥が深いので、[こちら](http://perldoc.jp/docs/perl/5.14.1/perlre.pod)を見ておくと良いでしょう。

---

# 9. ハッシュ（連想配列）

Key-value型のデータ構造。%なんとか みたいな書き方をします。
ハッシュの中の単体要素を取り出すときは `$ハッシュ名{要素名}` のように指定します。

    my %human = (
        name => 'ytnobody',
        age => 34,
        sex => male,
    );
    print "$human{name} is $human{sex}, and $human{age} years old.\n";

---

# 10. ファイルとディレクトリ

ファイルを開くときには `open` を使う。なお、モードを指定する必要が有る。

    open my $fh, '<', '/path/to/somefile';
    for my $line (<$fh>) {
        print $line;
    }
    close $fh;
    
---

## ファイルオープン時のモード

* `<` : 読み込み専用
* `>` : 書き込み専用（上書きモード）
* `>>` : 書き込み専用（追記モード）

---

## ディレクトリの中身調べたりする

`glob` を使うと、unixの`ls`コマンドのような指定方法でファイル/ディレクトリ一覧を得ることができる。

    my @logs = glob '/path/to/some/*.log';
